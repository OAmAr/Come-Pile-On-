\begin{document}
\pagenumbering{arabic} 
\arabic{1} 
\renewcommand{\baselinestretch}{1}

\section{(Sub)Section and TOC}

\section{Line Spacing}

\section{Page Numbering}

\section{Vertical Spacing}

This section was fairly straightforward. If we see the vertical spacing command we
simply print out the N new lines (where N is the number specified) 

See the function vertical_space for details.

As an aside, since we were not asked to implement the hspace command we do not handle
it. As a result, writing the hspace command in the middle of text will break that line
of text (causing a newline to print). This happens in the test file latex.tst.

\section{Italics/Roman Fonts}

This section proved to be much more difficult than we expected. The first challenge
was to figure out how to print out italicized text. We discovered a sequence of
escape characters that controlled this in the Linux terminal so we decided to use that
as the indication of italics text. A word processor should easily be able to do the same
as the Linux terminal in this regard.

\subsection{Setting flags}
When we see an italics or roman slash command, we set the it_flag global variable 
appropriately (we then use this variable when formatting text). This works nicely
for the simple slash command, but this does not allow slash commands in curly braces
to reset the font type at the end. Thus, we pass the value of the it_flag through $$ before
we change it. This allows the curlyb options section to reset it once it has formatted the
text.

\subsection{Formatting the text}
In generate_formatted_text, before filling the line at all we check whether or not the 
escape characters should be printed. This happens if the current it_flag value does not
match the value from the last time generate_formatted_text was called. The reason this works is because the slash commands interrupt the text options so each time there is a 
font changing command generate_formatted_text will get called at some point before the next 
time the font is changed again.

If the it_flag value does not match the previous value, we copy the proper escape character
sequence into the current position of the line buffer by calling functions set_italics and 
clear_italics.

\subsection{Handling the line buffer}
The issue with this approach is our line buffer will be filled with characters that do not
actually get printed (other than to signal to switch to and from italics). To manage this,
we had to expand the line to be larger and keep track of the significant character count
of the line. We called this count text_index. We also keep track of the character count
of the escape characters, called spec_chars. This is useful when we right justify the line
as we don''t' want to include the escape characters in the length of the line.

\subsection{Printing differences}
Another challenge was that as the slash commands and curly brace options interrupt
textoptions, they would cause the text to be broken up. To deal with this, we decided
to only print the line buffer when it was full or when we had reached points where the
text for a given block should end (such as at the start of a new section, or the start
of a new begin block). 

More details can be found in the following functions:
\begin{itemize}
\item set_italics
\item clear_italics
\item right_justify
\item generate_formatted_text
\item print_line
\end{itemize}

\section{Paragraphs and Indentation}

\subsection{Paragraphs}
A new paragraph is detected in the source file when a ws option contains two newlines bac
to back. In latex.l when we detect this we pass a newline as well as a tab up through the
grammar which eventually gets stored into our textoption. Thus, we will see a newline
character in the textoption that gets sent to generate_formatted_text and this is our 
indication to start a new paragraph. To avoid messing up the line, when we detect this
newline we immediately print it out and skip to the next iteration in
generate_formatted_text. 

\subsection{Indentation}
A user can specify not to indent a new paragraph by using the newindent command. This gets
handled by the code in latex.l which passes along a newline rather than a newline and a tab
through the grammer if the no indent flag is set. This prevents the textoption from
receiving the tab and thus prevents indentation.

Also note that the no indent flag is set at each section and subsection header as the first
line afterwards is not supposed to be indented. The no indent flag gets cleared in latex.l
as it is not meant to persist.

\section{Right Justification}
This became somewhat tricky due to the escape characters from the italics section. In
general, the function iterates until the length of meaningful text will fill the out width.
The first space that occurs after a word is kept track of, then for each iteration we
iterate through the string starting from that offset until we find a space. Once we find a 
space, we add in a new space by shifting everything to the right one. We then move to the 
position of the next non-space character in the line to avoid doubling up on adding spaces.

Note that due to escape characters the text in latexout may not look justified. Rest
assured this is only becuase of the presence of the escapes characters which would not be
printed by a text processor that is processing the document. Note that the behavior works
fine in an Ubuntu 16.04 terminal.

\section{Single Blocks}

\section{Itemize And Enumerate}
We used stacks to keep track of the stack of our items and enumerations. itemize_stack
keeps track of the current nesting level of the blocks as well as the current option, 
either itemize or enumerate. In addition, there is the enumeration_stack which keeps
track of the count for each enumerate block on the stack. This allows us to nest
itemize and enumerate blocks and be able to keep track of what we should be printing
as well as keep seperate enumeration counts for each level (max of 3 levels).

Additionally, we have styled each level differently as such:

\begin{itemize}
\item Itemize Level 1
\begin{itemize}
\item Itemize Level 3
\begin{itemize}
\item Itemize Level 3
\end{itemize}
\end{itemize}
\end{itemize}
\begin{enumerate}
\item Enumerate Level 1
\begin{enumerate}
\item Enumerate Level 3
\begin{enumerate}
\item Enumerate Level 3
\end{enumerate}
\end{enumerate}
\end{enumerate}

In order to get the right justification to worked, we used the size of the stack multiplied
to the predefined tab spacing to subtract from the out width. This prevent the indentation
from causing the line to overfill. The function print_line was modified to print out spaces
according to the tab spacing and stack size before printing the line (which is at 0 if not
in an itemize or enumerate environment, resulting in no indentation).

For more details, please refer to the following:
\begin{itemize}
\item generate_item
\item print_line
\item stack implementation in util.c
\end{itemize}

\section{Center Blocks}

\section{Verbatim Blocks}

\section{Tables}

\subsection{Setting up the tables}
Getting tables to work was one of the most challenging parts of this project. We defined a
struct for a table in project.h. When a new table block is detected, the code in the bison
file generates a new table and sets the current_table global to the new table. As the
grammar parses the struct fields such as the column specification, label, caption, and 
position it updates the table. As entries are discovered they are added to the table as
well. We also keep track of whether the table was around or surrounded by a center block 
so that we know to center the text when printing it. We assumed a single entry in a table 
could not be more than 32 characters so it won''t' work with more than that at the moment,
but this is easily changeable.

\subsection{Printing the tables}
To print a table we parse through each entry and divide it into cells based on the location
of the ampersand. The maximum length of each column is noted so that the entries of each 
column can be justified properly. Then, print_table iterates over the matrix of cells and
justifies each (in accordance with the column spec), then adds the cell to the line buffer.
At the end of each row, the line is printed to print the row. Once all the rows are 
printed, if the table has a caption the caption is printed alongside the table id.

\subsection{Relocating tables}
We used a queue for tables with position 't' or 'b' so that we can delay printing
them. Each time a new page is started print_page_number will look at the queue and print
out the first page in it. This preserves the order in which the tables were input. We
assume that if there are multiple pages queued up that we are only supposed to change the
first. To print the 'b' tables, we check the line count each time it is incremented to see
if the remaining lines match the lines it will take to print the table. If so, we print it.
We followed the same assumption as above for the 'b' tables.

This will leave us with the issue that we may have leftover tables at the end of the
document. To fix this, we created a function cleanup_doc which repeatedly prints 't' and 'b'
tables (along with the page number when there is a new page). The function finishes the 
document by printing the last page number.

For more details on tables, see the following:
\begin{itemize}
\item new_table
\item free_table
\item set_cols
\item set_label
\item set_caption
\item add_entry
\item table_justify
\item print_table
\item table_lines
\item print_page_number
\item end_doc_cleanup
\item test_bottom
\item print_bottom
\item Table definition in project.h
\end{itemize}

\section{Type/Error Checking}

\subsection{Block Matching}
This is easy to do with a stack. We simply push all the end commands onto the block_stack
(each with their own id), then when we see a begin command we pop the stack and make sure
the id matches the current input. This ensures that we can not begin one type of block and
then end another before another begin command as this is invalid in latex. If the blocks
do not match, we throw an error and exit.

\subsection{Tabular Specification}
As we add entries to the table we check each one to make sure it is valid. We do this by
checking the ampersand count to ensure that it is 1 less than the column count of the
table. If it is not, we throw an error and exit.

\section{Misc}
We upped the text buffer from 512 bytes to 1024 as the text in latex.tst surpasses 512
characters.

\end{document}